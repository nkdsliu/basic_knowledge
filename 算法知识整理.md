# 数组
## 技巧
* 二分法
* 循环不变量（注意区间开闭，左闭右开还是左闭右闭，等号有无导致不同的边界值处理方式）
* 双指针、快慢指针（可以降低一个n级别的时间复杂度）
* 滑动窗口
* 移出数组/字符串元素时，未避免每次移出都是o(n)时间复杂度，可以采用[双指针](https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html)或[倒序](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%89%91%E6%8C%87Offer05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.md)方式
# 哈希表
* 数组，set，map，unordered_set，unordered_map
* 元素个数有限，如只包含小写字母时，可用数组代替set/map（数组占用空间少，且不用进行hash计算，耗时少）
## [哈希冲突解决](https://zhuanlan.zhihu.com/p/29520044)
# [链表](https://blog.csdn.net/ccblogger/article/details/81176338)
## 虚拟头结点
* 作用：因链表操作当前节点要用到当前节点的前一个节点，虚拟头结点可避免对头结点操作单独定义代码
* 链表初始化虚拟头(+尾）节点，以及链表节点数size；[例](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.md)
* 单链表声明虚拟头结点，指向下一个节点指针为nullptr
* 双向链表声明虚拟头结点和虚拟尾节点，每个节点两个指针（next和pre），虚拟头尾节点互指
* 循环链表声明虚拟头结点，指向下一个节点指针指向自己
* 双向循环链表声明虚拟头结点，两个指针均指向自己
* 对链表操作时要注意链表类型，正确处理链表节点的指针。（有时间把双向链表、循环链表、双向循环链表的代码都写一下）
## 注意循环终止条件的判断，注意维护当前节点的前一个和后一个节点
## 插入或删除
* 需创建虚拟头结点dummyHead，记录当前节点，前一个节点和后一个节点
# 二叉树
## 二叉树创建和遍历
* https://www.codenong.com/cs106016832/
* [非递归前中后序遍历](https://blog.csdn.net/zhangxiangDavaid/article/details/37115355)
* [递归&非递归层序遍历](https://blog.csdn.net/u013146882/article/details/72584312)
* https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/
# 排序算法
* 快希选堆（快些选对）为不稳定排序
* leetcode 912题：快排，[堆排](https://www.cnblogs.com/chengxiao/p/6129630.html)，归并排序实现
# 双指针
* 滑动窗口：两个指针指向同一数组，遍历方向相同且不会相交，指针中间的区域为当前窗口，常用于区间搜索
* 两指针指向同一数组，遍历方向相反时，数组一般是要预先排好序的
# [前缀和](https://juejin.cn/post/6944913393627168798)
* 一维前缀和，通常结合hashmap使用（[典型题](https://www.sohu.com/a/445342521_120437685)）
* 二维前缀和
# 回溯
## 去重问题
* 不可排序
  * 使用unordered_set对树层进行去重（数据范围小时可用数组代替set）
* 可排序
  * 组合、子集问题：used数组，unordered_set，或利用startIndex
  * 排列问题：used数组，unordered_set
* 可以不使用set时不要用set，因set的时间和空间复杂度较高
# 图论
## DFS和BFS
* 用邻接矩阵/表或标志位记录已访问过节点，避免重复遍历
* DFS判断是否存在路径，BFS寻找最短路径（[例题](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.md)）
* [DFS岛屿问题](https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)
* leetcode：第200题，1034题
## 拓扑排序
* 参考leetcode 101中拓扑排序章节，136页或[leetcode 210题题解](https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/)。
# [并查集](https://zhuanlan.zhihu.com/p/93647900)
* 包含合并和查询两种操作，用于解决元素的分组管理问题
* 可用路径压缩和按秩合并来优化效率，同时使用时不保证秩的严格准确
* 把整个数据集合并一遍再判断两个变量是否连通或统计连通分量的个数，注意合并条件的判断
* [例题1](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0684.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.md)，[例题2](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II.md)（无向图可以构成树的条件是没有环；有向图可以构成树的条件是没有环且没有入度大于等于2的节点；并查集可以用于判断是否有环，若两个点在添加图之前在并查集内找到了相同的根，说明有环，不能构成树）
# [记忆化搜索](https://blog.csdn.net/lovetaozibaby/article/details/121271551)
* [例题1](https://codeantenna.com/a/PPN5x2DlQT)，[例题2](https://www.codeleading.com/article/24555882656/)，[例题3](https://juejin.cn/post/6996508589732921380)（[动态规划解法](https://leetcode-cn.com/problems/out-of-boundary-paths/solution/chu-jie-de-lu-jing-shu-by-leetcode-solut-l9dw/)）
* [与动态规划区别](https://www.zhihu.com/question/60730045)
# [字典树/前缀树](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/)
# [分治算法](https://blog.csdn.net/hanx09/article/details/108277448)
* 例题解析可参见leetcode中对应题目（后两题不典型不用看）
# [二分查找](https://lesylin.com/2020/06/29/leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#%E6%9F%A5%E5%88%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A4%A7%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E5%85%83%E7%B4%A0)
* leetcode 4、33、34、35
# 先刷热题 HOT 100，再刷精选 TOP 面试题
* 可学习算法：图算法（[最短路径算法](https://drrany.github.io/ShortestPathAlgorithm/)），字典树，位运算，二进制运算，线段树，前缀树，采样算法（蓄水池抽样），单调栈和单调队列，数学题，合并区间，K路合并，双堆算法，矩阵，LRU算法，ac自动机，归并，排序算法
